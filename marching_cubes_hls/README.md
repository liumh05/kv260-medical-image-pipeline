# Marching Cubes HLS

基于HLS的Marching Cubes算法实现，用于从三维体数据中提取等值面网格。输入为NPY格式的体数据文件，输出为VTK格式的网格文件。

## 项目结构

```
marching_cubes_hls/
├── hls_src/
│   ├── marching_cubes_hls.h      # HLS顶层接口定义
│   ├── marching_cubes_hls.cpp    # Marching Cubes算法实现
│   ├── mc_tables.h               # Marching Cubes查找表
│   └── mc_tables.cpp             # 查找表数据
├── hls_testbench/
│   ├── test_marching_cubes_hls.cpp # 测试平台主程序
│   ├── npy_reader.h              # NPY文件读取器
│   ├── npy_reader.cpp            # NPY文件解析实现
│   ├── vtk_writer.h              # VTK文件写入器
│   └── vtk_writer.cpp            # VTK文件输出实现
├── vivado_design/
│   └── design_1.tcl              # Vivado Block Design脚本
└── vtk_render/
    └── pyvista_render.ipynb      # PyVista可视化示例
```

## 功能特性

- **硬件加速**：基于FPGA的并行处理实现
- **流式处理**：使用HLS Stream进行高效数据传输
- **内存优化**：双层缓存机制减少外部存储访问
- **标准接口**：支持NPY输入和VTK输出格式

## 技术规格

- **最大体数据尺寸**：128×128×128
- **最大顶点数**：1,000,000
- **最大三角形数**：2,000,000
- **数据类型**：float32
- **处理方式**：流式处理

## 算法原理

### Marching Cubes算法
Marching Cubes是一种经典的等值面提取算法，通过遍历体数据中的每个立方体单元，根据顶点值与等值的关系生成三角形面片。

### 核心步骤

1. **立方体分类**：根据8个顶点值与等值的关系确定立方体配置
2. **顶点插值**：在边上通过线性插值计算等值面与边的交点
3. **三角形生成**：基于查找表生成三角形面片
4. **流式输出**：将顶点和三角形通过Stream接口输出

### 优化策略

- **查找表加速**：使用预计算的边表和三角形表
- **缓存机制**：双层Z缓存减少内存访问
- **流水线处理**：通过HLS指令实现流水线优化

## 配置参数

可通过修改头文件中的宏定义调整配置：

```cpp
#define MAX_DIM 128              // 最大体数据维度
#define MAX_VERTICES 1000000     // 最大顶点数
#define MAX_TRIANGLES 2000000    // 最大三角形数
```

## 接口说明

### 顶层接口

```cpp
void marching_cubes_hls(
    const data_t* volume,           // 输入体数据
    int nx, int ny, nz,            // 体数据尺寸
    data_t isovalue,               // 等值
    hls::stream<Vertex>& vertex_stream,     // 顶点输出流
    hls::stream<Triangle>& triangle_stream, // 三角形输出流
    int* num_vertices,             // 顶点数量
    int* num_triangles             // 三角形数量
);
```

### 数据结构

```cpp
struct Vertex {
    vertex_t x, y, z;              // 顶点坐标
};

struct Triangle {
    index_t v0, v1, v2;            // 三角形顶点索引
};
```

## 使用方法

### 1. HLS综合

```bash
# 在Vitis HLS中打开项目
cd hls_src
vitis_hls -p marching_cubes_hls
```

### 2. 仿真测试

```bash
# 编译测试平台
cd hls_testbench
g++ -I../hls_src test_marching_cubes_hls.cpp npy_reader.cpp vtk_writer.cpp -o test_mc

# 运行测试
./test_mc input.npy 0.5 output.vtk
```

### 3. 参数说明

```bash
./test_mc <input.npy> <isovalue> <output.vtk> [--with-normals]
```

参数说明：
- `input.npy`: 输入NPY文件，形状为(1, D, H, W)或(D, H, W)
- `isovalue`: 等值，用于表面提取
- `output.vtk`: 输出VTK文件路径
- `--with-normals`: (可选)输出包含法向量的VTK文件

### 4. Vivado集成

```bash
# 导入IP到Vivado
source vivado_design/design_1.tcl
```

## 输入格式

### NPY文件要求
- **数据类型**：float32
- **形状**：(1, D, H, W) 或 (D, H, W)
- **字节序**：C-order（行优先）
- **维度限制**：D, H, W ≤ 128

### 支持的数据类型转换
- float32：直接使用
- int16/int32：自动转换为float32
- uint8：自动转换为float32

## 输出格式

### VTK Legacy PolyData格式
输出文件包含：
- 点数据：顶点坐标(x, y, z)
- 面数据：三角形面片（三个顶点索引）
- 法向量：可选的法向量数据

### 文件结构
```
# vtk DataFile Version 3.0
Generated by Marching Cubes HLS
ASCII
DATASET POLYDATA
POINTS <count> float
<vertex coordinates>
POLYGONS <count> <data_size>
<triangle indices>
```

## HLS优化方法详解

### 1. 存储器层次优化

#### 双层Z缓存设计
- **缓存架构**: 双层128×128×2的BRAM缓存
- **乒乓操作**: 交替加载Z平面，实现流式处理
- **减少外部访问**: 90%以上的数据访问在片内完成
```cpp
data_t z_plane_cache[2][128][128];  // 双层Z缓存
int cache_idx = z & 1;              // 乒乓索引
```

#### BRAM优化配置
- **绑定策略**: 使用`BIND_STORAGE`指定BRAM实现
- **端口配置**: T2P模式支持双端口并行访问
- **容量规划**: 支持128³体数据的完整处理

### 2. 查找表加速优化

#### 预计算查找表
- **边表(edgeTable)**: 256个立方体配置的边激活信息
- **三角表(triTable)**: 每种配置对应的三角形连接关系
- **边索引映射**: 优化的物理边到逻辑边的映射关系

#### 表访问优化
```cpp
#pragma HLS ARRAY_PARTITION variable=edgeTable complete
#pragma HLS ARRAY_PARTITION variable=triTable complete
// 完全分区实现并行查找
```

### 3. 循环和流水线优化

#### 多级流水线设计
- **外层流水线**: II=1的Z平面处理流水线
- **内层流水线**: II=12的立方体处理流水线
- **循环展开**: 关键循环完全展开减少迭代开销

#### 优化指令应用
```cpp
#pragma HLS PIPELINE II=12        // 立方体处理流水线
#pragma HLS UNROLL                 // 边创建循环展开
#pragma HLS ARRAY_PARTITION complete // 数组完全分区
```

### 4. 并行处理架构

#### 边并行计算
- **12边并行**: 同时计算立方体的12条边
- **顶点流水**: 边顶点计算和三角形生成的流水线处理
- **流式输出**: 使用HLS Stream实现连续数据流

#### 数据并行访问
```cpp
Vertex local_vertices[12];
#pragma HLS ARRAY_PARTITION variable=local_vertices complete
int vert_map[12];
#pragma HLS ARRAY_PARTITION variable=vert_map complete
```

### 5. 算法级优化

#### 数值精度优化
- **浮点处理**: IEEE 754单精度浮点支持
- **误差控制**: 微小负偏置避免浮点精度裂缝
- **边界处理**: 优化的边界条件检测和处理

#### 内存访问模式优化
- **连续访问**: 优化内存访问模式提高缓存命中率
- **预取策略**: 提前加载下一个Z平面数据
- **局部性利用**: 充分利用空间和时间局部性

### 6. 资源利用优化

#### DSP资源优化
- **浮点运算**: 合理利用DSP48E2单元
- **插值计算**: 优化的线性插值实现
- **运算调度**: 避免DSP资源冲突

#### LUT/FF资源控制
- **位宽控制**: 精确控制数据位宽减少资源占用
- **共享资源**: 多个计算单元共享查找表资源
- **流水线平衡**: 平衡各阶段资源使用

### 7. 性能瓶颈分析

#### 关键路径优化
- **插值计算**: 优化的除法运算实现
- **条件分支**: 减少复杂的条件判断
- **数据依赖**: 打破数据依赖提高并行度

#### 吞吐量优化
- **批处理**: 批量处理多个立方体
- **流水线深度**: 适当增加流水线深度
- **并行度**: 可配置的并行处理度

## 性能指标分析

### 理论性能
- **体数据处理**: 128×128×128体素@~100MHz
- **顶点生成**: 最大1M顶点@~50MHz有效吞吐
- **三角形生成**: 最大2M三角形@~30MHz有效吞吐

## 注意事项

1. **内存限制**：受FPGA片上存储限制，最大支持128³体数据
2. **边界处理**：自动处理体数据边界情况
3. **数值精度**：使用float32精度，注意浮点运算误差
4. **查找表**：确保使用完整的Marching Cubes查找表

## 调试与验证

### 功能验证
- 与C++参考实现对比结果正确性
- 通过PyVista等工具可视化验证输出

### 性能分析
- 使用Vivado HLS分析工具查看资源使用
- 监控流水线吞吐率和延迟
- 优化关键路径提高工作频率

